diff -r d824afd97d6a core/lib/unix_stubs.c
--- a/core/lib/unix_stubs.c	Tue May 20 12:24:57 2014 +0100
+++ b/core/lib/unix_stubs.c	Tue May 20 13:09:53 2014 +0100
@@ -75,7 +75,8 @@
   snprintf(buf2, MAX_ERROR_LEN, "%s (%s)\n", str, buf);
 #endif
   buf2[MAX_ERROR_LEN - 1] = '\0';
-  write(fd, buf2, strlen(buf2));
+  ssize_t ret = write(fd, buf2, strlen(buf2));
+  if (ret) {}
 }
 
 /* Maximum number of arguments plus one (for terminating NULL) that may
diff -r d824afd97d6a core_kernel/lib/core_gc.ml
--- a/core_kernel/lib/core_gc.ml	Tue May 20 12:24:57 2014 +0100
+++ b/core_kernel/lib/core_gc.ml	Tue May 20 13:09:53 2014 +0100
@@ -72,8 +72,8 @@
   | None -> current
   | Some v ->
       Option.iter logger
-        ~f:(fun f -> Printf.ksprintf f "Gc.Control.%s: %(%d%) -> %(%d%)"
-              name fmt current fmt v);
+        ~f:(fun f -> Printf.ksprintf f "Gc.Control.%s: %s -> %s"
+              name (sprintf fmt current) (sprintf fmt v));
       v
 ;;
 
diff -r d824afd97d6a core_kernel/lib/error.mli
--- a/core_kernel/lib/error.mli	Tue May 20 12:24:57 2014 +0100
+++ b/core_kernel/lib/error.mli	Tue May 20 13:09:53 2014 +0100
@@ -1,6 +1,6 @@
 open Sexplib
 
-include module type of Info with type t = private Info.t
+include module type of Info with type t = Info.t
 
 (* Note that the exception holds onto the [t]. *)
 val raise : t -> _
diff -r d824afd97d6a core_kernel/lib/pow_overflow_bounds.ml
--- a/core_kernel/lib/pow_overflow_bounds.ml	Tue May 20 12:24:57 2014 +0100
+++ b/core_kernel/lib/pow_overflow_bounds.ml	Tue May 20 13:09:53 2014 +0100
@@ -1,4 +1,4 @@
-(* This file was autogenerated by base/core/kernel/lib/generate/generate_pow_overflow_bounds.ml *)
+(* This file was autogenerated by git/core_kernel/lib/generate/generate_pow_overflow_bounds.ml *)
 
 (* We have to use Int64.to_int_exn instead of int constants to make
    sure that file can be preprocessed on 32-bit machines. *)
diff -r d824afd97d6a custom_printf/syntax/pa_custom_printf.ml
--- a/custom_printf/syntax/pa_custom_printf.ml	Tue May 20 12:24:57 2014 +0100
+++ b/custom_printf/syntax/pa_custom_printf.ml	Tue May 20 13:09:53 2014 +0100
@@ -100,10 +100,84 @@
   in
   String.concat l ~sep:""
 
+module Count = struct
+  open CamlinternalFormatBasics
+
+  type ('a, 'b) seq =
+    | Z : ('a, 'a) seq
+    | S : ('a, 'b) seq -> (_ -> 'a, 'b) seq
+
+  let rec int_of_seq : type a b. (a, b) seq -> int = function
+    | S x -> int_of_seq x + 1
+    | Z -> 0
+
+  let count =
+    let rec loop_fmt : type a b c d e f. (a, b, c, d, e, f) fmt -> (a, f) seq = function
+      | Char fmt ->
+        S (loop_fmt fmt)
+      | Caml_char fmt ->
+        S (loop_fmt fmt)
+      | String (padding, fmt) ->
+        loop_padding padding (S (loop_fmt fmt))
+      | Caml_string (padding, fmt) ->
+        loop_padding padding (S (loop_fmt fmt))
+      | Int (_, padding, precision, fmt) ->
+        loop_padding padding (loop_precision precision (S (loop_fmt fmt)))
+      | Int32 (_, padding, precision, fmt) ->
+        loop_padding padding (loop_precision precision (S (loop_fmt fmt)))
+      | Nativeint (_, padding, precision, fmt) ->
+        loop_padding padding (loop_precision precision (S (loop_fmt fmt)))
+      | Int64 (_, padding, precision, fmt) ->
+        loop_padding padding (loop_precision precision (S (loop_fmt fmt)))
+      | Float (_, padding, precision, fmt) ->
+        loop_padding padding (loop_precision precision (S (loop_fmt fmt)))
+      | Bool fmt ->
+        S (loop_fmt fmt)
+      | Flush fmt ->
+        loop_fmt fmt
+      | String_literal (_, fmt) ->
+        loop_fmt fmt
+      | Char_literal (_, fmt) ->
+        loop_fmt fmt
+      | Format_arg (_, _fmtty, fmt) ->
+        S (loop_fmt fmt)
+      | Format_subst _ ->
+        failwith "TODO: support format substitution"
+      | Alpha fmt ->
+        S (S (loop_fmt fmt))
+      | Theta fmt ->
+        S (loop_fmt fmt)
+      | Formatting (_, fmt) ->
+        loop_fmt fmt
+      | Reader _ ->
+        failwith "reader not supported/1"
+      | Scan_char_set _ ->
+        failwith "reader not supported/2"
+      | Scan_get_counter _ ->
+        failwith "reader not supported/3"
+      | Ignored_param (_, _fmt) ->
+        failwith "reader not supported/4"
+      | End_of_format ->
+        Z
+    and loop_padding : type a b c. (a, b) padding -> (b, c) seq -> (a, c) seq = fun p x ->
+      match p with
+      | No_padding -> x
+      | Lit_padding _ -> x
+      | Arg_padding _ -> S x
+    and loop_precision : type a b c. (a, b) precision -> (b, c) seq -> (a, c) seq = fun p x ->
+      match p with
+      | No_precision -> x
+      | Lit_precision _ -> x
+      | Arg_precision -> S x
+    in
+    fun s ->
+      let CamlinternalFormat.Fmt_EBB fmt = CamlinternalFormat.fmt_ebb_of_string s in
+      int_of_seq (loop_fmt fmt)
+end
+
 let num_args loc (format : string) =
-  let module P = Printf.CamlinternalPr in
   let format = processed_format_string ~exploded_format_string:(explode loc format) in
-  (P.Tformat.ac_of_format (Obj.magic format)).P.Tformat.ac_rglr
+  Count.count format
 
 let get_sexp_of_quote () =
   try
diff -r d824afd97d6a sexplib/lib/conv.ml
--- a/sexplib/lib/conv.ml	Tue May 20 12:24:57 2014 +0100
+++ b/sexplib/lib/conv.ml	Tue May 20 13:09:53 2014 +0100
@@ -185,7 +185,9 @@
 
   let exn_addr_map : (int * weak_repr) Addrs.t ref = ref Addrs.empty
 
-  let get_exn_tag (exn : exn) = Obj.field (Obj.repr exn) 0
+  let get_exn_tag (exn : exn) =
+    let tag = Obj.field (Obj.repr exn) 0 in
+    if Obj.tag tag = Obj.string_tag then Obj.repr exn else tag
   let get_exn_tag_str_addr exn_tag = (Obj.magic (Obj.field exn_tag 0) : int)
   let get_exn_str_addr exn = get_exn_tag_str_addr (get_exn_tag exn)
 
diff -r d824afd97d6a type_conv/lib/pa_type_conv.ml
--- a/type_conv/lib/pa_type_conv.ml	Tue May 20 12:24:57 2014 +0100
+++ b/type_conv/lib/pa_type_conv.ml	Tue May 20 13:09:53 2014 +0100
@@ -1027,6 +1027,7 @@
   method! module_expr = function
     | MeFun (loc, _, _, _) as me -> self#fold_map_on_functor_arg <:str_item@loc< >> me
 
+    | MeAtt _
     | MeStr _
     | MeTyc _
     | MeNil _
@@ -1043,6 +1044,8 @@
     | sig_item -> super#sig_item sig_item
 
   method ignore_module_type = function
+    | MtAlias _
+    | MtAtt _
     | MtNil _
     | MtId _
     | MtFun _
